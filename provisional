import numpy as np
from scipy.signal import find_peaks
import serial
import time

# === CONFIGURACIÓN ===
FILE_NAME = "prueba.txt"     # Cambia si tu archivo se llama distinto
SAMPLING_RATE = 1000         # Hz (como en tu código original)
SERIAL_PORT = "/dev/ttyACM0" # Puerto serie
BAUDRATE = 115200
SLEEP_SECONDS = 120          # Cada cuánto se envía (2 min)

# === CARGA DE DATOS DESDE TXT ===
# Se asume que la señal ECG está en la última columna
data = np.loadtxt(FILE_NAME, comments="#")
x = data[:, -1]

# Mismo trozo que usabas antes: [-15000:-4000]
ecg = x[-15000:-4000] / 1024.0 / 1.1 * 3.3 - 1.5

# === CÁLCULO DEL BPM MEDIO ===
threshold = np.mean(ecg) + 2 * np.std(ecg)

peaks, _ = find_peaks(
    ecg,
    height=threshold,
    distance=int(0.25 * SAMPLING_RATE)  # mínimo 250 ms entre picos (~240 bpm máx)
)

if len(peaks) < 2:
    raise RuntimeError("No hay suficientes picos para calcular BPM.")

rr_intervals = np.diff(peaks) / SAMPLING_RATE  # en segundos
bpm_instant = 60.0 / rr_intervals
bpm_mean = np.mean(bpm_instant)

print("Picos detectados:", len(peaks))
print("BPM medio:", bpm_mean)

# === ENVÍO POR SERIAL DEL BPM MEDIO ===
ser = serial.Serial(SERIAL_PORT, BAUDRATE, timeout=1)
time.sleep(2)  # pequeña espera para que el puerto esté listo

try:
    while True:
        mensaje = f"{bpm_mean:.2f}\n"
        ser.write(mensaje.encode("utf-8"))
        print("Enviado:", mensaje.strip())
        time.sleep(SLEEP_SECONDS)
except KeyboardInterrupt:
    print("Detenido por teclado.")
finally:
    ser.close()
